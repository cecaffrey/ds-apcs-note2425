Matrix Recreate
 
 
1 0 0 0 1
0 1 1 0 1
1 0 1 1 1
1. Create and Count
   2 1 2 1 3
 
   -----------
 
2 | 1 0 0 0 1
 
3 | 0 1 1 0 1
 
4 | 1 0 1 1 1
 
 
Create a randomly sized matrix randomly filled with 0's and 1's. This part need not be recursive. The number of rows and columns should be independent random numbers between two and six, inclusive. For example, our matrix might have 3 rows and 5 columns, filled like:
 
Next count the number of 1's in each row and column, storing them in two arrays.  In the example, the rowCounts is [2 3 4] and the colCounts is [2 1 2 1 3].   Display these counts when you display the matrix, formatted like this:
 
2. Re-create
Working backwards from those two arrays of counts, recursively create a matrix of 0's and 1's that has the same row and column counts. The new matrix may be the same as or different from the original matrix, but it must have the same counts.  You are not allowed to use Math.random. You should think in terms of a recursive permutation of 0’s and 1’s.  Keep trying out different matrices, systematically and exhaustively permuting those 0's and 1's, until you find a matrix that has matching row and column counts, then print it and exit the program.  That's the base case.
   2 1 2 1 3
 
   -----------
 
2 | 0 1 0 0 1
 
3 | 1 0 1 0 1
 
4 | 1 0 1 1 1
 
 
 
Using the row and column counts as given in the example, your code could generate this matrix, which happens to have a different arrangement of 0’s and 1's.
 
Here is the main and the headers of the methods in the shell.  What does each method do?
 
public class MatrixRecreate
{
 public static void main(String[] args)
 {
    int[][] matrix = TheMatrix.create();
    int[] rowcount = new int[matrix.length];
    int[] colcount = new int[matrix[0].length];
    TheMatrix.count(matrix, rowcount, colcount);
    TheMatrix.display(matrix, rowcount, colcount);
    TheMatrix.re_create(rowcount, colcount);
    int[][] new_matrix = TheMatrix.getRecreatedMatrix();
    if( new_matrix == null )
       System.out.println("Did not find a match.");
    else
       TheMatrix.display( new_matrix, rowcount, colcount );
}
}
class TheMatrix
{
 //do not instantiate recreatedMatrix yet. Only instantiate and set that in recur.
 private static int[][] recreatedMatrix = null;
 public static int[][] getRecreatedMatrix()
 public static int[][] create()
 public static void count(int[][] matrix, int[] rowcount, int[] colcount)
 public static void display(int[][] matrix, int[] rowcount, int[] colcount)
public static void re_create(int[] orig_rowcount, int[] orig_colcount)
 private static void recur(int[][] new_matrix, int[] orig_rowcount,
                                              int[] orig_colcount, int row, int col)
 private static boolean compare(int[][] new_matrix, int[] orig_rowcount,
                                                    int[] orig_colcount)
 
 
Discussion
Filling the matrix with 0's and 1's is an example of an exhaustive, "brute force," recursive permutation, which we saw before in Left Right.  The difference is that Matrix Recreate is two-dimensional.  You need to cover all rows and columns with 1, then cover all rows and columns with 0.   The recursion part will create a tree that mixes-and-matches everything with everything else.  
 
There many ways to fill a matrix.   Here is a possible strategy for a target matrix that is 3-by-2.
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
1
 
 
 
 
 
 
 
 
 
 
 
 
0
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
1
1
 
 
 
 
 
 
 
 
 
 
 
1
0
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
1
1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
1
1
 
 
 
 
 
 
 
 
 
 
1
1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
1
1
 
 
 
 
 
 
 
 
 
 
1
0
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
1
1
 
 
 
 
 
1
1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Et cetera.
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
1
1
 
 
 
 
 
1
1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
1
 
 
 
 
 
 
0
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
1
1
 
 
1
1
 
 
1
1
 
 
1
1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
1
1
 
 
1
1
 
 
1
1
 
 
1
1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
1
1
 
 
1
0
 
 
0
1
 
 
0
0
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Hint 1: Pay attention to the behavior of row and col in your recursive code:
 
private static void recur(int[][] new_matrix, int[] orig_rowcount,
                                       int[] orig_colcount, int row, int col)
{
//base case
recur(______________, ____________, ______________ ,______, ______);
 
 
Hint 2:  Be sure to use the debugger and watch as your matrix is populated.
 
Testing:  Test several normal cases, of course.
              Test the extreme cases, such as a matrix with all 1’s or all 0’s.  
              Test matrices that are 2x6, 6x2, and square.
