Extra Help on MazeGrandMaster 2
 
/**recur until you find E, then build the path with (r,c) locations
  and the number of steps, e.g. ((5,0),10),((5,1),9),((6,1),8),
     ((6,2),7),((6,3),6),((6,4),5),((6,5),4),((6,6),3),((5,6),2),
     ((4,6),1),((4,7),0)
  as you build, choose the shortest path at each step
  returns empty String if there is no path
  precondition: Start can't match with Exit””
*/
public String findShortestPath(int r, int c)
 
You need the base cases which return "".  When you reach ‘E’ you need to return the ((r,c),step) numbers as a String.  
 
Before the recursions, place a temporary mark.  
 
Make four String variables to save the ((r,c),step) String created by the four recursions of findShortestPath.  Recur in all four directions.
 
Make four int variables to save the steps returned by getPathLength. Remember that if the string is empty, getPathLength returns 999.
 
You can visualize the (r,c)’s stored in the recursive tree at each level like this:
W W W W W W W W
W 1,1 1,2 1,3 1,4 W 1,6 W
W W 2,2 W 2,4 2,5 2,6 W
W 3,1 3,2 3,3 3,4 W 3,6 W
W 4,1 W 4,3 W W 4,6 4,7
5,0 5,1 W 5,3 W W 5,6 W
W 6,1 6,2 6,3 6,4 6,5 6,6 W
W W W W W W W W
 
 
 
 
 
The recursive calls stop at ‘E’  
 
 
 
 
 
As the recursive calls return, change the temporary mark.
 
As the recursive calls unwind themselves (going backwards from the ‘E’), the 4-way branching tree looks at the smallest step at each level, increments that step, and concatenates the appropriate ((r,c),step) string.
 
Here is a sample run using maze1:​
Shortest length path is: 10
Shortest path is: ((5,0),10),((5,1),9),((6,1),8),((6,2),7),((6,3),6),
((6,4),5),((6,5),4),((6,6),3),((5,6),2),((4,6),1),((4,7),0)
WWWWWWWW
W....W.W
WW.W...W
W....W.W
W.W.WW*E
S*W.WW*W
W******W
WWWWWWWW
