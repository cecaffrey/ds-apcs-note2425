AVL Trees
6
v
3 8
z
4
AVL Trees 1
n(2)
3
4 n(1)
Height of an AVL Tree
Fact: The height of an AVL tree storing n keys is O(log n).
Proof: Let us bound n(h): the minimum number of internal
nodes of an AVL tree of height h.
We easily see that n(1) = 1 and n(2) = 2
For n > 2, an AVL tree of height h contains the root node,
one AVL subtree of height n-1 and another of height n-2.
That is, n(h) = 1 + n(h-1) + n(h-2)
Knowing n(h-1) > n(h-2), we get n(h) > 2n(h-2). So
n(h) > 2n(h-2), n(h) > 4n(h-4), n(h) > 8n(n-6), â€¦ (by induction),
n(h) > 2in(h-2i)
Solving the base case we get: n(h) > 2 h/2-1
Taking logarithms: h < 2log n(h) +2
Thus the height of an AVL tree is O(log n)
AVL Trees 3
Trinode Restructuring
let (a ,b ,c ) be an inorder listing of x , y , z
perform the rotations needed to make b the topmost node of
the three
a=z
(other two cases
are symmetrical)
b=y
T0
T0
c=x
T1
b=y
T2 T3
a=z c=x
case 1: single rotation
(a left rotation about a)
T0 T1 T2 T3
a=z
c=y
b=x
T1 T2
case 2: double rotation
(a right rotation about c,
then a left rotation about a)
T3
b=x
a=z
c=y
T0 T1 T2 T3
AVL Trees 5
/ /
AVL Tree Definition
AVL trees are
balanced.
An AVL Tree is a
binary search tree
such that for every
internal node v of T,
the heights of the
children of v can
4
44
2
3
17 78
1
2
32 50
1
1
48 62
88
differ by at most 1 .
An example of an AVL tree where the
heights are shown next to the nodes:
AVL Trees 2
1
Insertion in an AVL Tree
Insertion is as in a binary search tree
Always done by expanding an external node.
Example: 44
44
c=z
17 78
17 78
a=y
32 50 88
32 50 88
48 62
48 62
b=x
54
w
before insertion after insertion
AVL Trees 4
Insertion Example, continued
5
44
z
2
6
4
17 78
2
1
3
y
32 50
1
4
7
1
88
2
x
1
48 62
3
1
5
54
T3
unbalanced...
T0 T2
4
T1
44
4
2
3
x
17
2
62
6
y z
1
2 2
32 50
1
3
78
1
1
5
7
...balanced
48
54
88
T2
T0 T1
AVL Trees 6
T3
1
Restructuring
(as Single Rotations)
Single Rotations:
a = z
single rotation
b = y
b = y
a = z
c = x
c = x
T 0
T 3
T1
T 0 T 1 T2
T 2
c = z
single rotation
b = y
b = y
a = x
c = z
a = x
T 3
T3
T0
T 2
T 2
T1
T0
T1
AVL Trees 7
T 3
Removal in an AVL Tree
Removal begins as in a binary search tree, which
means the node removed will become an empty
external node. Its parent, w, may cause an imbalance.
Example: 44
44
17
62
17
62
32 50
78
50
78
48
54
88
48
54
88
before deletion of 32 after deletion
AVL Trees 9
Running Times for
AVL Trees
a single restructure is O(1)
using a linked-structure binary tree
find is O(log n)
height of tree is O(log n), no restructures needed
insert is O(log n)
initial find is O(log n)
Restructuring up the tree, maintaining heights is O(log n)
remove is O(log n)
initial find is O(log n)
Restructuring up the tree, maintaining heights is O(log n)
AVL Trees 11
/ /
Restructuring
(as Double Rotations)
double rotations:
double rotation
a = z
b = x
c = y
a = z
c = y
b = x
T0
T2
T 2
T3 T0
T1
T3
T1
double rotation
c = z
b = x
a = y
a = y
c = z
b = x
T0
T 2
T 3 T0
T2
T 3 T1
T1
AVL Trees 8
Rebalancing after a Removal
Let z be the first unbalanced node encountered while travelling
up the tree from w. Also, let y be the child of z with the larger
height, and let x be the child of y with the larger height.
We perform restructure(x) to restore balance at z.
As this restructuring may upset the balance of another node
higher in the tree, we must continue checking for balance until
the root of T is reached
62
a=z
44
44
78
w
17
62
b=y
17
50 88
50
78
c=x
48
54
48
54
88
AVL Trees